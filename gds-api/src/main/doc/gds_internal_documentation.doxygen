/*! \page gds_internal_documentation GDS Developers Documentation

\section gds_intro_sec Introduction
The Gemini Data Service (GDS) is the system that will (partially) replace the Gemini Data Handling System (DHS) for GIAPI
based instruments, such as GPI.

The GDS is written in Scala, so doxygen cannot generate its API documentation. It can be accessed at <a href="../scaladocs/index.html">GDS API</a>.

\section gds_bundles_sec Bundles
The GDS is comprised of the following bundles:
- \subpage gds-actors-composer
- \subpage gds-config-validator
- \subpage gds-constant-actors
- \subpage gds-epics-actors
- \subpage gds-postprocessing-policy
- \subpage gds-fits-checker
- \subpage gds-fits-updater
- \subpage gds-health
- \subpage gds-instrument-status-actors
- \subpage gds-keywords-database
- \subpage gds-observation-state
- \subpage gds-obsevent-handler
- \subpage gds-odb-actors
- \subpage gds-performance-monitoring
- \subpage gds-seqexec-actors
- \subpage gds-static-header-receiver
- \subpage gds-web-ui
- \subpage gds-web-ui-configuration
- \subpage gds-web-ui-keywords
- \subpage gds-web-ui-logs
- \subpage gds-web-ui-status

\section design_sec Design Issues

\subsection composition_sec Data Values Composition
The GDS is a component that listen for Observation Events sent from an instrument and that reacts to them
by sampling the state of the Observatory. observation database, instrument, etc. The sampled information is then added
to the data files produced by the instrument. This process is called value composition, where all sampled values upon
observation events are composed into the data file.

The design uses the concept of actors or agents that are independent objects that can sample the information. This design
makes it simple to keep track of the progress and make each of these actors, a single purpose, very simple to implement
component.

It also makes it easy to extend the composition as the core components can discover new modules in charge of gathering
these values

\subsection datalabel_sec Data Label Generation
Currently, the dataset names (or datalabels) generation is performed via a control command by the DHS, at the request of
the seqexec. The seqexec later specifies who will contribute data to this dataset, at which point itself and the
contributors can start sending data.
A first study of the following documents and code was done:
- ICD 3: Bulk Data Transfer
- ICD 1.9/3.2: Science Instrument to Data Handling System
- dhs/dhs/dhsData/list.C
- dhs/dhs/dhsData/ctl.C

This investigation shows that the datalabel generation functionality is fairly independent from the data storing
functionality, in a way that no files are created, and no internal state changes (except for a list of the last labels
generated), when labels are generated. Furthermore, data can be sent with arbitrary datalabels not generated by the DHS.

So, there are three main alternatives for instruments using the GDS:
- Continue with the seqexec request datalabels to the DHS, and then not sending any data to the DHS, but to the GDS. The
major disadvantage is a dependence on the DHS for GIAPI based instruments.
- Extract the datalabel generation from the DHS to an external service that the DHS can query for most instruments, and
the seqexec can query for GIAPI based instruments. The major disadvantage is the risk of modifying a complex piece of
software like the DHS. For consistency and simplicity, if this option is taken, the communication with the new external
service should use the same protocol as the one used in \ref fits_seqexec_sec.
- Generate datalabels independently in GDS and DHS, and ensure no collisions will happen by changing the naming convention.

\subsection fits_seqexec_sec Sending FITS Headers from Seqexec to GDS
The FITS headers that the seqexec provides, must be passed to the GDS. There aren't many suitable remote communication
alternatives supported by tcl and java/scala. The most suitable seems to be XMLRPC, which has implementations in both
languages, and is relatively simple, but much higher level than using plain http or tcp.

\section random_sec Random Rambling
Just some notes:
- The "current" DHS is not tags/current, but the trunk.
- Can't get a tcl script to communicate with my local DHS. Seems to be a problem with my IMP service.
- A C++ client does work.
- Can generate datalabels.
- If data arrives with a label that already exists, a dash and a correlative number is appended to the name.

\section gds_performance_testing GDS Performance Tests
\subsection  Introduction
Testing was done to check the performance of GDS when confronted to many simultaneous keywords. To do
so a special testing program and configuration was created

- A test program was created in giapi-glue-cc that can post a large amount
of status updates and seqexec keywords, and execute a sequence of observation events
- A configuration matching the test program war written in gmp-server/src/main/etc/conf/gds-keywords-highcount.conf
and it needs to be referred from GDSConfigurationServiceImpl-default.cfg
- To test the EPICS part a casdb instance should be running

The main objective is to determine the bounds of how fast GDS can process a file comparable to those required for GPI
As a reference, we'd ideally be able to have expositions of one second and process the file in a comparable time

The first round of tests were carried out on 7/20/2011 on an iMac with all the components on the local machine
A second round of tests were carried out on 9/08/2011 on an iMac with all the components on the local machine

\subsection Procedure
The test procedure is as follows

-# Checkout and build the giapi-osgi project
-# Edit the GDSConfigurationServiceImpl-default.cfg to point to the gds-keywords-highcount.conf file
-# Start casdb at the giapi source code dir:
    java -jar casdb/target/casdb-0.1.0-jar-with-dependencies.jar -f integration-tests/src/test/resources/cas500channels.xml  
-# Start the gmp-server and verify it is running normally
-# Go to giapi-glue-cc/run/examples, build and run
    ./runExample obshighcount
  This produces an output like:
\verbatim
Starting GDS High Count Simulation Test
Simulating datalabel S1311707323
<?xml version="1.0" encoding="UTF-8"?><methodResponse xmlns:ex="http://ws.apache.org/xmlrpc/namespaces/extensions"><params><param><value><boolean>1</boolean></value></param></params></methodResponse>
time to post xmlrpc req:2.668 [ms]
2011-07-26 15:08:43,516 [0x7fff7109fcc0] INFO  giapi.ServicesUtilImpl - Property requested for key: DHS_SCIENCE_DATA_PATH
TempFile : /tmp/S1311707323.fits
POST 0
2011-07-26 15:08:43,786 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_PREP datalabel: S1311707323
POST 1
2011-07-26 15:08:44,187 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_ACQ datalabel: S1311707323
POST 2
2011-07-26 15:08:46,187 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_ACQ datalabel: S1311707323
POST 3
2011-07-26 15:08:46,388 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_READOUT datalabel: S1311707323
POST 4
2011-07-26 15:08:46,389 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_READOUT datalabel: S1311707323
POST 5
2011-07-26 15:08:46,392 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_DSET_WRITE datalabel: S1311707323
POST 6
2011-07-26 15:08:46,593 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_DSET_WRITE datalabel: S1311707323
[15:08:46]
\endverbatim
-# This should produce a file with updated FITS keywords under:
    /tmp/N-S1311707323.fits
-# The timing of the events can be seen on the gmp log at
    gmp-server/runner/logs/gmp.log
-# The following gives the average time after 160 rounds
\verbatim
2011-09-08 14:42:56,585 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Average timing for event OBS_PREP: 6[ms]
2011-09-08 14:42:56,585 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Timing for event OBS_PREP DataLabel S1315503772: 5[ms]
2011-09-08 14:42:56,586 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Average timing for event OBS_START_ACQ: 128[ms]
2011-09-08 14:42:56,586 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Timing for event OBS_START_ACQ DataLabel S1315503772: 1040[ms]
2011-09-08 14:42:56,586 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Average timing for event OBS_END_ACQ: 14[ms]
2011-09-08 14:42:56,586 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Timing for event OBS_END_ACQ DataLabel S1315503772: 18[ms]
2011-09-08 14:42:56,586 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Average timing for event OBS_START_READOUT: 2[ms]
2011-09-08 14:42:56,586 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Timing for event OBS_START_READOUT DataLabel S1315503772: 1[ms]
2011-09-08 14:42:56,587 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Average timing for event OBS_END_READOUT: 2[ms]
2011-09-08 14:42:56,587 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Timing for event OBS_END_READOUT DataLabel S1315503772: 1[ms]
2011-09-08 14:42:56,587 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Average timing for event OBS_START_DSET_WRITE: 1[ms]
2011-09-08 14:42:56,587 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Timing for event OBS_START_DSET_WRITE DataLabel S1315503772: 1[ms]
2011-09-08 14:42:56,587 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Average timing for event OBS_END_DSET_WRITE: 200[ms]
2011-09-08 14:42:56,587 INFO  [ForkJoinPool-1-worker-9] .aspen.gds.obsevent.handler.ReplyHandler -  Timing for event OBS_END_DSET_WRITE DataLabel S1315503772: 141[ms]
2011-09-08 14:42:56,597 INFO  [ForkJoinPool-1-worker-16] .aspen.gds.obsevent.handler.ReplyHandler -  Writing updated FITS file at S1315503772 took PT0.012S
\endverbatim

\subsection Results
After analyzing some runs we can get some conclusions:
-# It seems that for the amount of items required (80 SEQEXEC, 500 Status, 250 EPICS items) we need approximately 3[s] for the collection to be reliable
-# Constructing actors takes an appreciable time, for example constructing 80 SEQEXEC actors takes 30-40 [ms]
Construction of 508 STATUS actors takes 122 [ms] 
-# The waiting part of KeywordSetComposer in the method waitForDataAndReply is suboptimal, e.g for SEQEXEC actor it produces:
    Waiting for data took 109 [ms] 
-# Requesting STATUS items is very fast, for example taking 160-180 [ms] to read 508 status items, this is probably coming mostly from the
issue in 3
-# Posting a SEQEXEC XMLRPC request takes around 2-10[ms] however experience would suggest that making one HTTP request per keyword could be quite slow  
-# Reading EPICS channels seems quite fast 1-2[ms] each
-# It seems is not reliable to read so many EPICS channels and there are exceptions reading some of them. It could be this is due to the cas side
rather than the GDS part
-# The first 
\subsection Recommendations
Some recommendations:
-# Redesign 3 so that waiting for data collection takes app the same as the slowest actor
-# Change the Posting of keywords to post many keywords at once and/or change it to use o lighter protocol
-# Replace reading EPICS channels directly and instead use the latest snapshot stored in memory

\section gds_memory_leaks_testing_sec GDS Memory Leaks Testing
Testing for memory leaks are possible by using the acqloop.sh script at the src/examples dir in giapi-glue, and then
checking the GDS using visualvm or jconsole

\li Start the GMP-GDS as indicated in the \ref gmp_user_manual.
\li Start the sequence command example in <tt> giapi-glue-cc/src/examples/ </tt> with: <tt>$ ./acqloop.sh </tt>. You may want to edit the script to change the amount of iterations
\li Start jconsole (Installed as part of the JDK) and make it connect to the org.apache.felix.main.Main process
\li The script should run for quite a while sending observation commands in sequence to the GDS and then to the simulated instrument
\li The output of the script would look like:
\verbatim
Starting Observation Process Example
> POST / HTTP/1.1
Host: localhost:12345
Accept: */*
Content-Type: text/xml
Content-Length: 507

< HTTP/1.1 200 OK
< Server: Apache XML-RPC 1.0
< Connection: close
< Content-Type: text/xml
< Content-Length: 199
< 
* we are done reading and this is set to close, stop send
* Closing connection #0
* About to connect() to localhost port 12345 (#0)
*   Trying 127.0.0.1... * connected
* Connected to localhost (127.0.0.1) port 12345 (#0)
> POST / HTTP/1.1
Host: localhost:12345
Accept: */*
Content-Type: text/xml
Content-Length: 437

< HTTP/1.1 200 OK
< Server: Apache XML-RPC 1.0
< Connection: close
< Content-Type: text/xml
< Content-Length: 199
< 
* we are done reading and this is set to close, stop send
* Closing connection #0
<?xml version="1.0" encoding="UTF-8"?><methodResponse xmlns:ex="http://ws.apache.org/xmlrpc/namespaces/extensions"><params><param><value><boolean>1</boolean></value></param></params></methodResponse><?xml version="1.0" encoding="UTF-8"?><methodResponse xmlns:ex="http://ws.apache.org/xmlrpc/namespaces/extensions"><params><param><value><boolean>1</boolean></value></param></params></methodResponse>Retrieving Data file location
2011-07-06 22:04:19,752 [0x7fff7109fcc0] INFO  giapi.ServicesUtilImpl - Property requested for key: DHS_SCIENCE_DATA_PATH
DataSciencePath : /tmp
TempFile : /tmp/S20110427-01.fits
POST 0
2011-07-06 22:04:19,771 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_PREP datalabel: S20110427-01
POST 1
2011-07-06 22:04:20,771 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_ACQ datalabel: S20110427-01
POST 2
2011-07-06 22:04:22,772 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_ACQ datalabel: S20110427-01
POST 3
2011-07-06 22:04:24,773 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_READOUT datalabel: S20110427-01
POST 4
2011-07-06 22:04:25,773 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_READOUT datalabel: S20110427-01
POST 5
2011-07-06 22:04:26,774 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_START_DSET_WRITE datalabel: S20110427-01
POST 6
2011-07-06 22:04:27,775 [0x7fff7109fcc0] INFO  giapi.JmsProducer - Observation Event: OBS_END_DSET_WRITE datalabel: S20110427-01

\endverbatim

\li On jconsole the memory consumption can be checked on the Memory tab as shown below:
\image html jconsole_memory_tab.png

*/
